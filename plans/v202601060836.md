# 扩展 compare_headings.py 支持格式对比

**创建时间**: 2026-01-06 08:36
**目标**: 扩展 `compare_headings.py` 以支持标题内部格式（加粗）的对比

---

## 1. 背景与问题

### 当前问题
`compare_headings.py` 只对比标题的**纯文本内容**，完全忽略格式信息：

```python
# 当前实现：删除所有格式标记
def clean_latex_text(text: str) -> str:
    text = re.sub(r'\\[a-zA-Z]+', '', text)  # ❌ 删除 \bfseries、\textbf 等
    ...
```

### 用户需求
Word 模板中的标题可能包含**混合格式**，例如：
- "**立项依据**与研究内容"（"立项依据"加粗）
- "（一）**立项依据**与研究内容（建议8000字以内）"

当前工具无法检测 LaTeX 是否正确实现了这种混合格式。

---

## 2. 技术方案

### 2.1 Word 端：提取格式化文本

从 Word 文档的 `run` 级别提取格式信息：

```python
from docx import Document
from typing import List, Dict, Tuple

def extract_formatted_text_from_word(paragraph) -> List[Dict[str, any]]:
    """
    从 Word 段落中提取带格式信息的文本片段

    Returns:
        [
            {"text": "立项依据", "bold": True},
            {"text": "与研究内容", "bold": False},
            {"text": "（建议8000字以内）", "bold": False}
        ]
    """
    fragments = []
    for run in paragraph.runs:
        fragments.append({
            "text": run.text,
            "bold": run.bold if run.bold is not None else False
        })
    return fragments
```

### 2.2 LaTeX 端：解析格式化文本

从 LaTeX 代码中解析 `\textbf{}` 和 `\bfseries`：

```python
import re
from typing import List, Dict, Tuple

def extract_formatted_text_from_latex(latex_text: str) -> List[Dict[str, any]]:
    """
    从 LaTeX 文本中提取带格式信息的片段

    支持的格式：
    - \textbf{文本}     （推荐）
    - {\bfseries 文本}  （传统方式）
    - {\textbf 文本}    （罕见但存在）

    Returns:
        [
            {"text": "立项依据", "bold": True},
            {"text": "与研究内容", "bold": False}
        ]
    """
    fragments = []

    # 模式 1: \textbf{...}
    textbf_pattern = r'\\textbf\{([^}]+)\}'
    pattern = f'(?P<prefix>[^{{}}]*?){textbf_pattern}(?P<suffix>[^{{}}]*?)'

    # 匹配并分割
    remaining = latex_text
    bold_segments = []

    # 先提取所有 \textbf{} 片段
    for match in re.finditer(textbf_pattern, latex_text):
        start = match.start()
        end = match.end()
        inner_text = match.group(1)

        # 记录加粗片段的位置和内容
        bold_segments.append({
            "start": start,
            "end": end,
            "text": inner_text,
            "bold": True
        })

    # 按位置排序
    bold_segments.sort(key=lambda x: x["start"])

    # 构建完整片段列表
    last_end = 0
    for seg in bold_segments:
        # 添加加粗前的普通文本
        if seg["start"] > last_end:
            normal_text = latex_text[last_end:seg["start"]]
            normal_text = clean_latex_commands(normal_text)
            if normal_text:
                fragments.append({"text": normal_text, "bold": False})

        # 添加加粗文本
        fragments.append({"text": seg["text"], "bold": True})
        last_end = seg["end"]

    # 添加剩余的普通文本
    if last_end < len(latex_text):
        normal_text = latex_text[last_end:]
        normal_text = clean_latex_commands(normal_text)
        if normal_text:
            fragments.append({"text": normal_text, "bold": False})

    return fragments

def clean_latex_commands(text: str) -> str:
    """清理 LaTeX 命令，但保留 \textbf 和 \bfseries"""
    # 删除除 \textbf、\bfseries 外的所有命令
    text = re.sub(r'\\(?!textbf|bfseries)[a-zA-Z]+', '', text)
    text = re.sub(r'\{|\}', '', text)
    text = text.strip()
    return text
```

### 2.3 格式对比算法

对比两个片段列表的格式一致性：

```python
def compare_formatted_text(word_fragments: List[Dict],
                          latex_fragments: List[Dict]) -> Dict[str, any]:
    """
    对比 Word 和 LaTeX 的格式化文本

    Returns:
        {
            "match": true/false,
            "word_text": "立项依据与研究内容",
            "latex_text": "立项依据与研究内容",
            "differences": [
                {
                    "type": "bold_mismatch",
                    "word_fragment": {"text": "立项依据", "bold": True},
                    "latex_fragment": {"text": "立项依据", "bold": False},
                    "position": "0-4"
                }
            ]
        }
    """
    # 提取纯文本进行初步对比
    word_text = "".join(f["text"] for f in word_fragments)
    latex_text = "".join(f["text"] for f in latex_fragments)

    if word_text != latex_text:
        return {
            "match": False,
            "reason": "text_mismatch",
            "word_text": word_text,
            "latex_text": latex_text
        }

    # 对齐片段并对比格式
    differences = []
    word_pos = 0
    latex_pos = 0
    word_idx = 0
    latex_idx = 0

    while word_idx < len(word_fragments) and latex_idx < len(latex_fragments):
        word_frag = word_fragments[word_idx]
        latex_frag = latex_fragments[latex_idx]

        # 计算当前片段的文本长度
        word_len = len(word_frag["text"])
        latex_len = len(latex_frag["text"])

        # 找到最小长度
        min_len = min(word_len, latex_len)

        # 对比前 min_len 个字符的格式
        for i in range(min_len):
            if word_frag["bold"] != latex_frag["bold"]:
                char_pos = word_pos + i
                differences.append({
                    "type": "bold_mismatch",
                    "position": char_pos,
                    "char": word_frag["text"][i],
                    "word_bold": word_frag["bold"],
                    "latex_bold": latex_frag["bold"]
                })

        # 更新位置
        word_pos += min_len
        latex_pos += min_len
        word_frag["text"] = word_frag["text"][min_len:]
        latex_frag["text"] = latex_frag["text"][min_len:]
        word_len -= min_len
        latex_len -= min_len

        # 如果 Word 片段用完了，移到下一个
        if word_len == 0:
            word_idx += 1
        # 如果 LaTeX 片段用完了，移到下一个
        if latex_len == 0:
            latex_idx += 1

    return {
        "match": len(differences) == 0,
        "word_text": word_text,
        "latex_text": latex_text,
        "differences": differences
    }
```

---

## 3. 输出格式

### 3.1 HTML 报告增强

在现有 HTML 报告中添加格式对比结果：

```html
<div class="item difference">
    <div class="key">section_1</div>
    <div class="format-comparison">
        <!-- Word 渲染 -->
        <div class="rendered-text word">
            <span class="bold">立项依据</span>与研究内容
        </div>
        <!-- LaTeX 渲染 -->
        <div class="rendered-text latex">
            <span>立项依据</span>与研究内容
        </div>
        <!-- 差异标记 -->
        <div class="diff-marker">
            ⚠️ 位置 0-3: Word 加粗，LaTeX 未加粗
        </div>
    </div>
</div>
```

### 3.2 LaTeX 修复建议

自动生成修复代码：

```latex
% 当前：
\section{立项依据与研究内容（建议8000字以内）}

% 建议修改为：
\section{\textbf{立项依据}与研究内容（建议8000字以内）}
```

---

## 4. 实现步骤

### Phase 1: 核心功能（最小可用版本）

| 步骤 | 文件 | 内容 |
|------|------|------|
| 1 | `compare_headings.py` | 添加 `extract_formatted_text_from_word()` 函数 |
| 2 | `compare_headings.py` | 添加 `extract_formatted_text_from_latex()` 函数 |
| 3 | `compare_headings.py` | 添加 `compare_formatted_text()` 函数 |
| 4 | `compare_headings.py` | 修改主流程，对每个标题调用格式对比 |
| 5 | `compare_headings.py` | 在输出中添加格式差异信息 |

**交付物**：
- 命令行输出包含格式差异
- 识别出哪些标题的加粗样式不一致

### Phase 2: 可视化增强

| 步骤 | 文件 | 内容 |
|------|------|------|
| 6 | `compare_headings.py` | 增强 HTML 报告，渲染格式化文本 |
| 7 | `compare_headings.py` | 添加样式：加粗文本用 `<b>` 或 `<span class="bold">` |
| 8 | `compare_headings.py` | 添加差异高亮显示 |

**交付物**：
- HTML 报告直观显示 Word 和 LaTeX 的格式差异

### Phase 3: 自动修复建议

| 步骤 | 文件 | 内容 |
|------|------|------|
| 9 | `compare_headings.py` | 生成 LaTeX 修复代码片段 |
| 10 | `compare_headings.py` | 输出修复建议到单独文件（如 `fix_heading_format.tex`） |
| 11 | `SKILL.md` | 更新文档，说明如何使用格式对比功能 |

**交付物**：
- 自动生成可复制的 LaTeX 修复代码
- 更新后的 SKILL.md 文档

---

## 5. 边界情况处理

### 5.1 Word 端复杂格式

| 情况 | 处理方式 |
|------|----------|
| 嵌套格式（加粗+斜体） | 优先报告加粗，忽略其他格式 |
| 多个 run 合并（"立"和"项"分别加粗） | 智能合并连续的同格式片段 |
| 空白 run | 过滤掉空文本片段 |

### 5.2 LaTeX 端复杂语法

| 语法 | 支持优先级 |
|------|-----------|
| `\textbf{文本}` | ✅ P1（优先支持） |
| `{\bfseries 文本}` | ✅ P2 |
| `{\textbf 文本}` | ⚠️ P3（低优先级） |
| `\DeclareRobustCommand{\specialbold}[1]{\textbf{#1}}` | ❌ 不支持（需用户自定义） |

### 5.3 文本对齐问题

| 问题 | 解决方案 |
|------|----------|
| Word 和 LaTeX 文本内容不一致 | 先报告文本不匹配，跳过格式对比 |
| 特殊字符（半角/全角空格） | 标准化后再对齐 |
| 标点符号差异 | 报告并标记差异位置 |

---

## 6. 测试用例

### 测试数据准备

```python
# 用例 1: 简单加粗
word: "立项依据与研究内容"
    ├─ "立项依据" (bold=True)
    └─ "与研究内容" (bold=False)

latex: "\\textbf{立项依据}与研究内容"
# 预期: match=True

# 用例 2: 加粗位置错误
latex: "立项依据\\textbf{与研究内容}"
# 预期: match=False, differences=[{position: 0-3, word_bold=True, latex_bold=False}]

# 用例 3: 完全未加粗
latex: "立项依据与研究内容"
# 预期: match=False, differences=[{position: 0-3, word_bold=True, latex_bold=False}]

# 用例 4: 复杂格式
word: "（一）立项依据与研究内容（建议8000字以内）"
    ├─ "（一）" (bold=False)
    ├─ "立项依据" (bold=True)
    ├─ "与研究内容" (bold=False)
    └─ "（建议8000字以内）" (bold=False)

latex: "（一）\\textbf{立项依据}与研究内容（建议8000字以内）"
# 预期: match=True
```

---

## 7. 兼容性保证

### 向后兼容

```python
# 新增命令行参数：--check-format（默认关闭）
parser.add_argument('--check-format', action='store_true',
                   help='检查格式（加粗）是否一致（默认仅检查文本）')

# 默认行为保持不变：只检查文本内容
if not args.check_format:
    # 使用原有的 clean_latex_text() 逻辑
    pass
else:
    # 使用新的格式对比逻辑
    pass
```

---

## 8. 估计工作量

| 阶段 | 工作内容 | 预计时间 |
|------|----------|----------|
| Phase 1 | 核心功能实现 | 2-3 小时 |
| Phase 2 | 可视化增强 | 1-2 小时 |
| Phase 3 | 自动修复建议 | 1-2 小时 |
| 测试 | 测试用例编写与验证 | 1 小时 |
| 文档 | 更新 SKILL.md | 0.5 小时 |

**总计**: 5.5-8.5 小时

---

## 9. 风险与限制

### 风险

| 风险 | 缓解措施 |
|------|----------|
| Word run 划分与实际语义不一致 | 提供手动调整功能 |
| LaTeX 格式解析遗漏边缘情况 | 分阶段支持，先支持常见语法 |
| 性能问题（大文档） | 仅解析标题，不处理正文 |

### 限制

- **不处理动态格式**：如 `\ifxxx` 条件格式
- **不处理自定义命令**：如 `\mybold{...}` 需用户手动配置
- **仅支持标题层对比**：不处理正文段落格式

---

## 10. 后续扩展可能性

### 10.1 支持更多格式

| 格式 | LaTeX 命令 | 优先级 |
|------|-----------|--------|
| 斜体 | `\textit{}` | P2 |
| 下划线 | `\underline{}` | P3 |
| 颜色 | `\textcolor{MsBlue}{}` | P4 |

### 10.2 支持自动修复

生成可直接应用的 patch 文件：

```diff
--- a/main.tex
+++ b/main.tex
@@ -15,7 +15,7 @@
 \begin{document}

-\section{立项依据与研究内容}
+\section{\textbf{立项依据}与研究内容}

 \input{extraTex/1.1.立项依据.tex}
```

---

## 11. 验收标准

- [ ] 能正确识别 Word 标题中的加粗片段
- [ ] 能正确解析 LaTeX 标题中的 `\textbf{}` 和 `\bfseries`
- [ ] 能报告格式不一致的位置和差异类型
- [ ] HTML 报告能直观显示格式差异
- [ ] 生成可复制的 LaTeX 修复代码
- [ ] 默认行为（不加 `--check-format`）与现有版本完全一致
- [ ] 通过所有测试用例

---

## 附录：代码修改范围

### 需要修改的文件

```
skills/make_latex_model/scripts/compare_headings.py
├── 新增函数
│   ├── extract_formatted_text_from_word()
│   ├── extract_formatted_text_from_latex()
│   └── compare_formatted_text()
├── 修改函数
│   ├── extract_from_word()       # 返回格式化片段
│   ├── extract_from_latex()      # 返回格式化片段
│   └── generate_html_report()    # 添加格式渲染
└── 新增参数
    └── --check-format            # 启用格式检查
```

### 需要新增的依赖

**无需新增依赖**，所有功能基于现有的 `python-docx` 和标准库实现。
